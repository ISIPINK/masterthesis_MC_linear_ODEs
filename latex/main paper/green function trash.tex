
Let's start from following form:
$$
    L(y)= f
$$
where $L$ is a linear operator, $f$ be generic for now and some linear condition
for $y$. All the methods we have in mind are some kind of integral transform:
$$
    y(t) = \int_{\Omega} \varphi(x) K(t,x)dx
$$
where the integral may also be a summation and we may chose $K(t,x), \Omega$ and let $\varphi(x)$ be our new unknown. Note that we don't know that such representation exist or even is well defined but we continue and fix this in the future (hopefully). If you sub this into the first equation you obtain the following:

\begin{align*}
    L \left(\int_{\Omega} \varphi(x) K(t,x)dx \right) & = f \Leftrightarrow \\
    \int_{\Omega} \varphi(x) L \left(K(t,x) \right)dx & = f
\end{align*}

this is a Fredholm integral equation of the first type in $\varphi(x)$
\url{https://en.wikipedia.org/wiki/Fredholm_integral_equation}
if we had
let $\Omega$ depend on $t$ in a certain way we would have obtained a Voltera integral
equation of the second kind
\url{https://en.wikipedia.org/wiki/Volterra_integral_equation}.

Let's derive the method of source green functions in this framework
\url{https://en.wikipedia.org/wiki/Green%27s_function}. 
This can be done by choosing the free things in a way something nice happens:
$$
    L \left(K(t,x) \right) = \delta(t-x)
$$

with the same  domain and initial/boundary conditions such that the ones of $y$ hold.
Choosing the initial/boundary conditions that way is easy but not trivial.

For a dirichlet boundary condition in $s$ the following can be done:

\begin{align*}
    y(s)   & = \int_{\Omega} \varphi(x) K(s,x)dx \Leftarrow                      \\
    K(s,x) & = \frac{y(s) l(x)}{\varphi(x)} \text{ and } 1 = \int_{\Omega}l(x)dx
\end{align*}

For a Neumann boundary condition in $s$ the following can be done:

\begin{align*}
    y'(s)   & = \int_{\Omega} \varphi(x) K'(s,x)dx \Leftarrow                      \\
    K'(s,x) & = \frac{y'(s) l(x)}{\varphi(x)} \text{ and } 1 = \int_{\Omega}l(x)dx
\end{align*}

with $l$ arbitrary. Linear type of initial/boundary conditions are very similar to this.
The $\varphi = f$ in the initial/boundary condition is annoying but can be avoided
by making the original initial/boundary condition $0$ by splitting explained in period1.\\

Going back because of our choice the following thing can be derived

\begin{align*}
    \int_{\Omega} \varphi(x) L \left(K(t,x) \right)dx & = f \Leftrightarrow \\
    \int_{\Omega} \varphi(x) \delta(t-x)dx            & = f \Leftrightarrow \\
    \varphi(t)                                        & = f
\end{align*}

Boundary Green functions deals with boundary conditions like how source Green functions deals with the source. The intuition behind them is the same as the solutions of a linear homogenous ODE that span a vector space.

$$
    y(t)= \int_{\partial B} \varphi(x) K(t,x) dx
$$

If you impose $L(y(t)) = 0$ on this you get the following:

\begin{align*}
    \int_{\partial B} \varphi(x) L(K(t,x)) dx & = 0 \Leftarrow \\
    L(K(t,x))                                 & = 0
\end{align*}

Again the initial conditions on $K(t,x)$ come from the original problem:

For a dirichlet boundary condition in $s$ the following can be done:

\begin{align*}
    y(s)   & = \int_{\partial \Omega} \varphi(x) K(s,x)dx \Leftarrow \\
    K(s,x) & = \delta(x-s) \text{ and } \varphi(s)= y(s)
\end{align*}

Other linear type initial/boundary conditions are very similar.

In the Green function method we searched an integral transform with a certain property
related to the equation that we were solving. Certain classes of integral
transformations have nice properties for a big class of equations.
A classic integral transform used for ODEs is the Fourier transform
\url{https://en.wikipedia.org/wiki/Fourier_transform}.
But we haven't figured
out how to deal with boundary conditions in this case.

The discrete version of an integral transform is a series transform,
in which you transfer information about the function to $\varphi_n$.
$$
    y(t) = \sum_{n=0}^{\infty} \varphi_n e_n(t)
$$
our original equation with this becomes:
\begin{align*}
    L \left(\sum_{n=0}^{\infty} \varphi_n e_n(t) \right) & = f \Leftrightarrow \\
    \sum_{n=0}^{\infty} \varphi_n L (e_n(t))             & = f
\end{align*}
Again there a lot of tricks you can pull of with this.
A convenient thing is when $L(e_{n}(t)) = \phi_{n}$ (and $e_{n}$
spans the space of functions which follow the initial/boundary conditions)
is bi-orthogonal basis against some $\psi_n$
$\left(\langle \phi_j \mid \psi_{k} \rangle= \delta_{jk}\right)$ .

\begin{align*}
    \sum_{n=0}^{\infty} \varphi_n \phi_{n}                                            & = f \Rightarrow                                   \\
    \left \langle \sum_{n=0}^{\infty} \varphi_n \phi_{n}\mid \psi_{j}  \right \rangle & =  \langle f\mid \psi_{j} \rangle \Leftrightarrow \\
    \sum_{n=0}^{\infty} \varphi_n \left \langle \phi_{n}\mid \psi_{j}  \right \rangle & =  \langle f\mid \psi_{j} \rangle \Leftrightarrow \\
    \sum_{n=0}^{\infty} \varphi_n \delta_{nj}                                         & =  \langle f\mid \psi_{j} \rangle \Leftrightarrow \\
    \varphi_j                                                                         & =  \langle f\mid \psi_{j} \rangle
\end{align*}
This means we have following expression for the solution:
\begin{align*}
    y(t) & = \sum_{n=0}^{\infty} \langle f(x)\mid \psi_{n}(x) \rangle e_{n}(t)  \Leftrightarrow \\
    y(t) & = \left\langle f(x)\mid  \sum_{n=0}^{\infty} \psi_{n}(x)e_{n}(t)  \right \rangle
\end{align*}
this expression in some cases depending on how the inner product is defined corresponds
with the Green function $G(t,x) =\sum_{n=0}^{\infty} \psi_{n}(x)e_{n}(t)$.

Related wikipedia page :
\url{https://en.wikipedia.org/wiki/Spectral_theory_of_ordinary_differential_equations}

This is probably not the only way to turn ODEs into integral equations. The Feynman-Kac formula
\url{https://en.wikipedia.org/wiki/Feynman%E2%80%93Kac_formula} 
is derived in an other way but still kind of obeys the general form we have given.

There are multiple ways to turn problems into integral equations for MC methods
but not all those integral equations gives you Monte Carlo methods with the same properties.
Things like: the type of the domain chosen, stochastic approximations made, what gets thrown
to the source term and what needs to be recursed on determine the properties of the Monte
Carlo method obtained.\\

Each Monte Carlo method doesn't have to be limited to $1$ integral equation.
One may use a different integral equation for each recursion step made in combination
with the different modifications discussed in period1. This makes for a big search space
of possible Monte Carlo algorithms. \\


Another thing to take in consideration is that finding Green functions is difficult a way
around that is by throwing everything in the source term but by doing this you probably
lose good properties. This approach is taken for example in Grid-Free Monte Carlo for
PDEs with Spatially Varying Coefficients. \\

To test that boundary Green functions work for ODEs we work out following example:
$$
    y'' = y, y(0) = 1, y'(1)=e
$$
with solution $y(t) = e^{t}$. We chose the splitting Green function method with
$\Omega = [-1,1],f = y$ as discussed as before. \\

Let's create integral representation of the boundary and source terms separately:

$$
    y''_{s} = f \text{ with } y_s(0)=0, y'_s(1)=0
$$
And the equation for the corresponding Green function:
$$
    G''(t,x) = \delta(t-x) \text{ with } G(0,x)=0, G'(1,x)=0
$$
$G$ must be something continuos piecewise linear with a jump of $1$ in the derivative
at $t = x$. By some algebra we find following solution:
$$
    G(t,x) =
    \begin{cases}
        -t & \text{if } t <  x   \\
        -x & \text{if } t \ge  x
    \end{cases}
$$
Write out the solution for $y_{s}(t)$:
$$
    y_{s}(t) = \int_{0}^{1} y(x) G(t,x) dx.
$$

We still have some problems to fix with the boundary Green functions ... \\
The boundary in for ODEs is discrete $\partial \Omega = \{0,1\}$.
So instead of an integral we have sum and Green function also splits into $2$...

$$
    y''_{b} = 0 \text{ with } y_{s}(0)=1, y'_{s}(1)= e
$$
Let's call the boundary function $K$ so that we don't confuse it with $G$.
So we have $K(t,0)$ and $K(t,1)$.The solution for these are easily found:

\begin{align*}
    K''(t,0) & = 0 \text{ with } K(0,0)=1, K'(0,1)=0 \Rightarrow \\
    K(t,0)   & =1
\end{align*}

\begin{align*}
    K''(t,1) & =0 \text{ with } K(1,0)=0, K'(1,1)=1 \Rightarrow \\
    K(t,1)   & =t
\end{align*}

Write out the solution for $y_{b}(t)$:
$$
    y_{b}(t) = 1 + e t
$$

If you put everything together you get:
$$
    y(t) = 1+et +\int_{0}^{1} y(x) G(t,x)dx.
$$
In the implementation we use Russian Roulette  with probability $1-\frac{1}{1.3}$ always for stopping.
In code this looks like:

